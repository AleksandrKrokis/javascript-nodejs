'use strict';

var path = require('path'),
    crypto = require('crypto'),
    PassThrough = require('stream').PassThrough,
    _ = require('lodash-node'),
    should = require('should'),
    sinon = require('sinon'),
    map = require('map-stream'),
    gutil = require('gulp-util');

var cache = require('../index');

require('mocha');

describe('gulp-cache', function () {
    var sandbox,
        fakeFileHandler,
        fakeTask;

    beforeEach(function (done) {
        sandbox = sinon.sandbox.create();

        // Spy on the fakeFileHandler to check if it gets called later
        fakeFileHandler = sandbox.spy(function (file, cb) {
            file.ran = true;

            if (Buffer.isBuffer(file.contents)) {
                file.contents = new Buffer(file.contents.toString('utf8') + '-modified');
            }
            
            cb(null, file);
        });
        fakeTask = map(fakeFileHandler);

        cache.fileCache.clear('default', done);
    });

    afterEach(function () {
        sandbox.restore();
    });

    it('throws an error if no task is passed', function () {
        var shouldThrow = function () {
            var proxied = cache();
        };

        shouldThrow.should.throw();
    });

    describe('in streaming mode', function () {
        it('does not work', function () {
            // create the fake file
            var fakeStream = new PassThrough(),
                fakeFile = new gutil.File({
                    contents: fakeStream
                });

            // Create a proxied plugin stream
            var proxied = cache(fakeTask, {
                key: function (file, cb) {
                    // For testing async key generation
                    setTimeout(function () {
                        cb(null, '123');
                    }, 1);
                },
                value: function (file, cb) {
                    // For testing async value generation
                    setTimeout(function () {
                        cb(null, {
                            ran: file.ran,
                            cached: true
                        });
                    }, 1);
                }
            });

            // write the fake file to it
            var writeFile = function () {
                proxied.write(fakeFile);
            };

            writeFile.should.throw();
        });
    });

    describe('in buffered mode', function () {
        it('can clear all the cache', function (done) {
            cache.clearAll(function (err) {
                done(err);
            });
        });

        it('can clear specific cache', function (done) {
            var fakeFileCache = {
                    removeCached: sandbox.spy(function (category, hash, done) {
                        return done();
                    })
                },
                someKeyHash = crypto.createHash('md5').update('somekey').digest('hex'),
                fakeFile = new gutil.File({
                    contents: new Buffer('something')
                });

            var toClear = cache.clear({
                name: 'somename',
                fileCache: fakeFileCache,
                key: function () {
                    return 'somekey';
                }
            });

            toClear.write(fakeFile);

            toClear.once('data', function () {
                fakeFileCache.removeCached.calledWith('somename', someKeyHash).should.equal(true);

                done();
            });
        });

        it('only caches successful tasks', function (done) {
     