'use strict';

var fs          = require('fs'),
    _           = require('underscore'),
    elements    = require(__dirname + '/objects/index'),
    dxfParser   = require('dxf-parsing').Parser;

var Parser = function Parser() {};

/**
 * Convert Svg file into Svg object
 * @param {object}      svg                 xml2js object
 * @param {function}    callback            Callback function
 */
Parser.convertXml = function convertXml(svg, callback) {
    if(svg == null || typeof svg.svg == 'undefined' || svg.svg == null){
        callback(new Error("Your SVG is empty or invalid"));
        return;
    }

    var elements = Parser.parseXmlNode(svg.svg);
    callback(null, elements);
};

/**
 * Convert JSON file into Svg object
 * @param {object}      json                json object
 * @param {function}    callback            Callback function
 */
Parser.convertJson = function convertJson(json, callback) {
    if(typeof json.elements == 'undefined' || json.elements.length == 0){
        callback(new Error("Your SVG is empty or invalid"));
        return;
    }

    var elements = Parser.parseJson(json.elements);
    callback(null, elements);
};

/**
 * Parse svg possibles nodes : <rect>, <g>, ...
 * @param {object}      node                xml2js node
 * @returns {Array}                         node elements convert to SvgObject type
 */
Parser.parseXmlNode = function parseXmlNode(node) {
    var nodes = [];

    _.each(node, function (content, index) {
        switch (index) {
            case 'g' :
                nodes = _.union(nodes, Parser.parseXmlGroup(content));
                break;
            case 'polygon' :
                nodes = _.union(nodes, Parser.parseXmlPolygon(content));
                break;
            case 'polyline' :
                nodes = _.union(nodes, Parser.parseXmlPolygon(content, true));
                break;
            case 'rect' :
                nodes = _.union(nodes, Parser.parseXmlRect(content));
                break;
            case 'text' :
                nodes = _.union(nodes, Parser.parseXmlText(content));
                break;
            case 'image' :
                nodes = _.union(nodes, Parser.parseXmlImage(content));
                break;
            case 'circle' :
                nodes = _.union(nodes, Parser.parseXmlCircle(content));
                break;
        }
    });

    return nodes;
};

/**
 * Parse json elements
 * @param {Array}      elements               xml2js node
 * @returns {Array}                           node elements convert to SvgObject type
 */
Parser.parseJson = function parseJson(elements) {
    var nodes = [];

    _.each(elements, function (element) {
        switch (element.type) {
            case 'g' :
                nodes.push(Parser.parseJsonGroup(element));
                break;
            case 'polygon' :
                nodes.push(Parser.parseJsonPolygon(element));
                break;
            case 'polyline' :
                nodes.push(Parser.parseJsonPolygon(element, true));
                break;
            case 'rect' :
                nodes.push(Parser.parseJsonRect(element));
                break;
            case 'text' :
                nodes.push(Parser.parseJsonText(element));
                break;
            case 'image' :
                nodes.push(Parser.parseJsonImage(element));
                break;
            case 'circle' :
                nodes.push(Parser.parseJsonCircle(element));
                break;
        }
    });

    return nodes;
};

/**
 * Parse Group Elements Array
 * @param {Array}   array                   xml2js elements array
 * @returns {Array}                         Groups array
 */
Parser.parseXmlGroup = function parseXmlGroup(array) {
    var groups = [];

    _.each(array, function (item) {
        groups.push(elements.Group.fromNode(item));
    });

    return groups;
};

/**
 * Parse Group json element
 * @param {object}  elem                    Group element in JSON format
 * @returns {object}                        Group object
 */
Parser.parseJsonGroup = function par