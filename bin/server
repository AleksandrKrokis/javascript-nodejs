#!/usr/bin/env node

const config = require('config');
const co = require('co');
const app = require('app');
const log = require('log')();

co(function*() {

  yield* app.waitBootAndListen(config.server.host, config.server.port);

  log.info("app is listening");

}).catch(function(err) {
  throw err;
});

process.on('message', function(msg) {
  if (msg == 'shutdown') { // PM2 sends this on graceful reload
    shutdown();
  }
});


function shutdown() {
  // The process is going to be reloaded
  // Have to close all database/socket.io/* connections

  co(function*() {
    log.info("closing the app...");
    yield* app.close();
    log.info("app closed");
  }).then(function() {
    log.info("exiting");
    process.exit(0);
  }, function(err) {
    log.error(err);
  });

  var dieDelay = process.env.PM2_GRACEFUL_TIMEOUT || 4000;
  // I have 4000ms to close all connections
  setTimeout(function() {
    log.error("App is stopping for too long! Will be killed now!");
    // kill is accomplished by PM2
  }, dieDelay - 100);

}

// отслеживаем unhandled ошибки
// https://iojs.org/api/process.html#process_event_rejectionhandled
var unhandledRejections = [];
process.on('unhandledRejection', function(reason, p) {
  p.trackRejectionId = Math.random();
  var report = {
    err: reason,
    trackRejectionId: p.trackRejectionId
  };

  log.error(report, "unhandledRejection");
  unhandledRejections.push(p);
});

process.on('rejectionHandled', function(p) {
  var index = unhandledRejections.indexOf(p);
  unhandledRejections.splice(index, 1);
  log.error({ trackRejectionId: p.trackRejectionId }, "rejectionHandled");
});
